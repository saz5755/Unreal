언리얼 프로그래밍 Part.2

1강

언리얼 게임 FrameWork을 활용한 게임 제작 방식의 이해
강의 예제에 사용되는 프로젝트와 기본C++ 클래스 생성
향후 운영될 C++ 프로젝트 운영 규칙의 이해

게임 콘텐츠의 구조
 게임 제작을 위해 언리얼 엔진은 자체적으로 설계한 프레임웍을 제공함
 이를 게임플레이 프레임웍(Gameplay Framework)이라 부름, 줄여서 게임 프레임웍
 언리얼 게임 프레임웍의 각 구성 요소를 파악하고, 이를 확장하면서 게임을 제작하는 것을 권장

월드(World)
 게임 콘텐츠를 담기 위해 제공되는 가상의 공간
 월드는 시간, 트랜스폼, 틱을 서비스로 제공한다.
 월드 세팅이라는 콘텐츠 제작을 위한 기본 환경 설정을 제공한다.
 월드의 기본 단위는 액터(Actor)로 정의되며, 액터 클래스는 언제나 접두사 A를 사용한다.

월드의 역할 
 게임 콘텐츠를 담는 공간 (Transform)
 게임 콘텐츠의 진행 (Tick)
 게임 흐름을 위한 시간 (Time)
 기본 환경 설정 (World Setting)
 월드의 단위 구성 요소 (Actor)

게임 모드(Game Mode)
 게임 규칙을 지정하고 게임을 판정하는 최고 관리자 액터. 형태가 없다.
 언리얼 엔진에서 하나의 게임에는 반드시 하나의 게임 모드만 존재한다.
 게임 모드에서 입장할 사용자의 규격을 지정할 수 있음.
 멀티플레이어 게임에서 판정을 처리하는 절대적 권위의 심판

게임 모드의 역할
 플레이어 입장 관리
 게임의 최종 승패 관리
 게임의 규칙 관리
 게임 데이터 검증 (멀티플레이 게임)

기믹(Gimmick)
 게임 진행을 위한 이벤트를 발생시키는 사물 액터
 주로 이벤트 발생을 위한 충돌 영역을 설정하는데, 이를 트리거(Trigger)라고 한다.
 트리거를 통해 캐릭터와 상호 작용하고, 월드에 액터를 스폰해 콘텐츠를 전개한다.

기믹의 역할
 월드 내 사물과 상호 작용을 수행
 지정된 조건을 만족하면 이벤트를 발생
 월드에 물체를 스폰(Spawn)시킬 수 있음

플레이어(Player)
 게임에 입장한 사용자 액터. 형태가 없다.
 게임 모드의 로그인을 통해 사용자가 게임 월드에 입장하면 플레이어가 생성된다. 
 싱글 플레이 게임에는 0번 플레이어가 설정된다.
 사용자와의 최종 커뮤니케이션을 담당한다. ( 예) 입력 장치의 해석, 화면 장치로의 출력)

플레이어의 역할
 게임에 입장한 사용자와의 1:1 대응
 사용자의 현태 상태 및 데이터를 관리
 사용자 입력의 1차 처리 (필요시)
 사용자 화면에 대응하는 카메라 관리
 사용자 화면에 나타나는 HUD UI 관리

폰(Pawn)
 무형의 액터인 플레이어가 빙의해 조종하는 액터
 길찾기를 사용할 수 있으며, 기믹 및 다른 폰과 상호작용한다.
 폰 중에서 인간형 폰을 별도로 캐릭터라고 지칭한다.

폰의 역할
 빙의(Possess)를 통해 플레이어와 연결
 사용자 입력의 실제 처리
 사용자 화면에 대응되는 카메라 설정
 기믹과의 상호작용
 현재 상태에 적합한 애니메이션 재생

게임의 제작 과정
 이번 과정에서 제작할 싱글플레이 게임 제작 5단계
 (1강은 블루프린트를 사용해 3단계로 작업)
 1단계 : 월드 설정과 게임 모드 생성
 2단계 : 플레이어 폰의 입출력 및 모션 설정 (언리얼 엔진이 제공하는 삼인칭 템플릿을 활용)
 3단계 : 캐릭터에 반응하는 기믹 설계
 4단계 : 게임 데이터와 NPC 인공지능
 5단계 : UI연동 및 게임 제작 마무리

최종 예제에서 확장할 내용
 기본 템플릿을 사용하지 않고 직접 제작
 두 가지의 카메라 모드를 제공 (숑더뷰, 탑뷰)
 액션 입력을 통한 콤보 공격의 구현
 아이템 애셋을 활용한 무기 상자의 구현
 NPC 레벨 정보를 스프레드시트로 관리
 플레이어와 전투하는 NPC 인공지능의 구현
 UI 연동과 게임의 마무리

프로젝트 소스코드 폴더 규칙
 게임 플레이를 구성하는 요소별로 폴더를 제작해 관리
  Game : 게임 모드와 게임 설정에 관련된 클래스 (이번 강의에서 생성)
  Gimmick : 기믹 배경 물체에 관련된 클래스
  Player : 플레이어에 관련된 클래스 (이번 강의에서 생성)
  Input : 플레이어 입력에 관련된 클래스
  Character : 기본 캐릭터와 PC 및 NPC에 관련된 클래스 (이번 강의에서 생성)
  Action : 캐릭터 액션에 관련된 클래스
  Item : 캐릭터 아이템에 관련된 클래스
  Stat : 캐릭터 스탯에 관련된 클래스
  AI : NPC 인공지능에 관련된 클래스
  UI : UI에 관련된 클래스
  Physics : 물리 충돌체 설정에 관련된 전처리기
  Interface : 인터페이스 클래스르 모아둔 폴더

클래스 생성 규칙
 모든 클래스는 AB(ArenaBattle의 약자)의 접두사로 시작함
 폴더마다 다른 폴더와의 의존성을 최소화
 다른 폴더의 클래스에 접근할 때 가급적 인터페이스를 통해 접근
 헤더 경로를 찾기 쉽도록 모듈.Build.cs 파일에 모듈의 폴더를 Include 경로에 설정
  PublicIncludePaths.AddRange(new string[]{"모듈이름"}); 추가
[가급적이면 다른 폴더의 헤더를 직접 참조하지 않도록 구성하는 것이 바람직]

최초 생성할 클래스
 게임을 구성하는 기본 골격의 설정
 캐릭터는 PC와 NPC를 구분해 구현할 예정
 게임 모드에서는 입장할 플레리어의 규격을 지정 (AABPlayerController, AABCharacterPlayer)

새로운 맵 생성
File - New Level
(기본 바닥 지우고 강의용 메시 드래그해서 사용함)

Window - Place Actors - Player Start(실행시 스폰 위치)

File - Save Current LEvel As.. - 현재 폴더 - Maps
=> 월드와 레벨 저장

Edit - ProjectSetting - Maps & Modes - Default Maps
=> 실행될 때 기본적으로 로딩 될 맵 설정

폴더 만들다가 빌드 에러나서
모듈.Build.cs - PublicIncludePaths.AddRange(new string[] {"모듈이름"}); 적용시킴

Content Browser - Add - Add Feature or Content Packs to the Project
(First Person, Third Person, Virtual Reality 등 템플릿 존재)

World Settings - Game Mode - GameMode Override - 설정할 Mode 적용

World Settings - Selected GameMode 
- Default Pwan Class - 등장시킬 조종할 사물의 대한 클래스 지정
- Player Controller Class - 언리얼에서 제공하는 기본 player contoller

=== {영상 확인} === 

오브젝트 우클릭 - Copy Reference 
static ConstructorHelpers::FClassFinder<클래스명> 변수명 (TEXT("Paste Reference"));

언리얼 게임프레임웤의 이해
 1. 콘텐츠 구조의 이해
 2. 게임 프레임웍의 구성 요소 살펴보기
 3. 단순한 게임 구조에서 출발해 점점 복잡한 게임으로 확장하는 제작 과정을 이해
 4. C++ 프로젝트 구성을 위한 기본 설정
 5. 게임 구성 요소를 폴더별로 분류하고, 헤더 참조를 최소화하는 규칙 수립

==========================================

2강

캐릭터와 입력 시스템
 C++ 액터와 마네킹 캐릭터의 제작

액터와 컴포넌트 개념의 이해
블루프린트로 확장 가능한 프로퍼티 설계
언리얼 엔진의 폰과 캐릭터 시스템의 이해
언리얼 엔진5이 제공하는 향상된 입력 시스템의 활용

액터의 구조
 월드에 속한 콘텐츠의 기본 단위를 액터라고 함
 액터는 트랜스폼을 가지며,월드로부터 틱과 시간 서비스를 제공받는다
 사실 액터는 논리적 개념일 뿐 컴포넌트를 감싸는 포장 박스에 불과함
 실질적인 구현은 컴포넌트가 진행하고 액터는 다수의 컴포넌트를 소유하고 있음
 다수의 컴포넌트를 대표하는 컴포넌트를 루트 컴포넌트(Root Component)라고 한다
 액터는 루트 컴포넌트를 가져야 하며, 루트 컴포넌트의 트랜스폼은 액터의 트랜스폼을 의미한다.

<BluePrint로 분수 만드는 과정>
Add - Blueprint Class - 상속받을 부모클래스를 지정(단순한 배경 사물은 Actor) - Save All - 더블 클릭
Component - Add - Static Mesh - DefaultSceneRoot 삭제 후 Root로 지정 
추가한 Static Mesh의 Detail패널에서 - Static Mesh를 추가
+  Static Mesh - Water 메시 추가
+ Point Light 추가후 Root의 자식으로 등록 (Light를 Root에 드래그 후 Attach)

<C++를 사용해서 만드는 과정>
Tools - New C++ Class - Actor를 부모로하는 클래스 생성 - Prop폴더 만든후 내부에 Class 생성 

=== <영상 확인> ===

C++ 액터에서 컴포넌트의 생성
 컴포넌트는 언리얼 오브젝트이므로 UPROPERTY를 설정하고 TObjectPtr로 포인터를 선언한다.
  언리얼5버전부터 헤더에 언리얼 오브젝트를 선언할 때 일반 포인터에서 TObjectPtr로 변경
 컴포넌트 등록
  CDO에서 생성한 컴포넌트는 자동으로 월드에 등록된다.
  NewObject로 생성한 컴포넌트는 반드시 등록절차를 거쳐야 한다. ( 예) RegisterComponent)
  등록된 컴포넌트는 월드의 기능을 사용할 수 있으며, 물리와 렌더링 처리에 합류한다.
 컴포넌트의 확장 설계
  에디터 편집 및 블루프린트로의 승계를 위한 설정
  UPROPERTY에 지정자(Specifier)를 설정할 수 있다.
 컴포넌트 지정자
  Visible / Edit : 크게 객체타입과 값타입으로 사용
  Anywhere / DefaultsOnly / InstanceOnly : 에디터에서 편집 가능 영역
  BlueprintReadOnly / BlueprintReadWrite : 블루프린트로 확장시 읽기 혹은 읽기쓰기 권한 부여
  Category : 에디터 편집 영역(Detail)에서의 카테고리 지정

폰의 기능과 설계
 폰은 액터를 상속받은 특별한 액터이며, 플레이어가 빙의해 입출력을 처리하도록 설계되어 있음.
 폰은 길찾기를 사용할 수 있으며, 일반적으로 세 가지 주요 컴포넌트로 구성된다.
  기믹과 상호작용을 담당하는 충돌 컴포넌트 (루트컴포넌트)
  시각적인 비주얼을 담당하는 메시 컴포넌트
  움직임을 담당하는 컴포넌트
 컴포넌트 중에서 트랜스폼이 없이 기능만 제공하는 컴포넌트를 액터컴포넌트라고 한다.

폰의 내부 구성
 충돌 컴포넌트(루트컴포넌트)
 비주얼 컴포넌트
 움직임 컴포넌트

캐릭터의 기본 구조
 캐릭터는 인간형 폰을 구성하도록 언리얼이 제공하는 전문 폰 클래스를 의미한다.
 캐릭터는 세 가지 주요 컴포넌트로 구성되어 있다.
  기믹과 상호작용을 담당하는 캡슐 컴포넌트(루트컴포넌트)
  애니메이션 캐릭터를 표현하는 스켈레탈 메시 컴포넌트
  캐릭터의 움직임을 담당하는 캐릭터 무브먼트(CharacterMovement) 컴포넌트

캐릭터의 내부 구성
 캡슐 컴포넌트 (루트컴포넌트)
 스켈레탈 메시 컴포넌트
 캐릭터 무브먼트 컴포넌트

C++로 설정 해줄 때 - 
메시의 경우에는 오브젝트를 지정해주면 됨, 애니메이션의 경우에는 클래스를 지정해줘야 함

입력시스템의 동작 방식
 플레이어의 입력은 컨트롤러를 통해 폰으로 전달됨
 입력을 컨트롤러가 처리할 수도, 폰이 처리할 수도 있는데, 일반적으로는 폰이 처리하도록 설정
  예) GTA같은 다양한 사물에 빙의하는 게임의 경우 폰이 유리

향상된 입력 시스템(Enhanced Input System)
 기존 입력시스템을 대체하고 언리얼 5.1부터 새롭게 도입
 사용자의 입력 설정 변경에 유연하게 대처할 수 있도록 구조를 재수립
 사용자 입력 처리를 네 단계로 세분화하고 각 설정을 독립적인 애셋으로 대체
=> 플레이어의 최종 입력을 게임 로직에서 진행하도록 함

향상된 입력시스템 동작 구성
 사용자의 입력 데이터를 최종 함수에 매핑하는 과정을 체계적으로 구성
 플랫폼에 따른 다양한 입력 장치의 설정
  예) 게임패드용 입력 매핑 컨텍스트, 키보드용 입력 매핑 컨텍스트
 입력 값의 변경
  예) AD/WS 입력값을 Y축과 X축으로 변경, 값 반전의 처리
 이벤트 발생 조건의 상세 설정
  예) 일반 버튼인가? 축 이동인가? 일정 이상 눌러야 하는가?

=== <영상 확인> ===

BeginPLay() : 입력 매핑 컨텍스트를 할당하는 역할
SetupPlayerInputComponent() : 언리얼 엔진의 input 시스템에서 입력 액션을 매핑

=============================

3강

캐릭터 컨트롤을 위한 각종 설정 옵션의 이해
데이터 애셋을 활용한 설정값의 체계적인 관리 
입력매핑 컨텍스트 활용법의 이해

캐릭터 컨트롤
 일반적으로 컨트롤러와 폰, 카메라, 스프링암, 캐릭터 무브먼트의 다섯 가지 요소를 사용해 설정.
 컨트롤러 : 입력자의 의미(목표 지점)을 지정할 때 사용. ControlRotation 속성
 폰 : 폰의 트랜스폼을 지정
 카메라 : 화면 구도를 설정하기 위해 사용. 주로 1인칭 시점에서 사용
 스프링 암 : 화면 구도를 설정하기 위해 사용. 주로 3인칭 시점에서 사용 
 캐릭터 무브먼트 : 캐리겉의 이동과 회전을 조정하는 용도로 사용

폰의 이동 함수
 Look 함수 : 마우스 입력으로부터 컨트롤러의 컨트롤 회전을 설정
 Move 함수 : 컨트롤러의 컨트롤 회전으로부터 Yaw 값을 참고해 이동 방향을 설정
 콘솔 커맨드 창(단축키 ~)으로부터 Control Rotation 값을 확인할 수 있음
 => 단축키(~) - DisplayAll PlayerController ControlRotation - 해당 속성 값이 마우스 입력에 따라서 변화되는 것을 확인할 수 있음

폰의 컨트롤 옵션
 Use Controller Rotation (Yaw / Roll / Pitch)
 컨트롤러에 지정된 COntrol Rotation 값의 폰에 Rotation을 맞출 것인가?
 이 옵션을 켜면 폰의 회전은 컨트롤러의 Control Rotation과 동기화 됨

스프링암의 컨트롤 옵션
 Use Pawn Control Rotation
 Inherit (Yaw / Roll / Pitch)
 Do Collision Test
 폰의 컨트롤 회전 (컨트롤러의 Control Rotation)을 사용할 것인가?
 부모 컴포넌트 (주로 RootComponent)의 회전을 그대로 따를 것인가? 
 스프링암 중간에 장애물이 있으면 앞으로 당길 것인가? (Camera라는 트레이스 채널을 사용)
 3인칭 시점 설정에 주로 사용

카메라의 컨트롤 옵션
 Use Pawn Control Rotation
 폰의 컨트롤 회전 (컨트롤러의 COntrol Rotation)을 사용할 것인가?
 스프링암에 달려있다면 스프링암 회전과 함께 고려
 1인칭 카메라 회전에 주로 사용

캐릭터 무브먼트의 이동 옵션
 Movement Mode : None, Walking, Falling
 땅(Ground)위에 있으면 Walking 모드
 땅 위에 없으면 Falling 모드
 이동 기능을 끄고 싶으면 None 모드
 이동 모드에서의 이동 수치 : MaxWalkSpeed
 폴링 모드에서의 점프 수치 : JumpZVelocity 

캐릭터 무브먼트의 회전 옵션
 Rotation Rate : 회전 속도의 지정
 Use Controller Desired Rotation : 컨트롤 회전을 목표 회전으로 삼고 지정한 속도로 달리기
 Orient Rotation To Movement : 캐릭터 이동 방향에 회전을 일치시키기
 폰의 회전 옵션과 충돌이 나지 않도록 주의

데이터 애셋
 UDataAsset을 상속받은 언리얼 오브젝트 클래스 
 에디터에서 애셋 형태로 편리하게 데이터를 관리할 수 있음
 캐릭터 컨트롤에 관련된 주요 옵션을 모아 애셋으로 관리
 
데이터 애셋의 관리
 두 가지의 컨트롤 모드를 제공
  현재 구현된 컨트롤 모드 : 3인칭 숄더 뷰
  추가로 구현할 컨트롤 모드 : 3인칭 쿼터 뷰
 입력키 V를 통해 컨트롤 설정을 변경
 ENUM을 통해 두 개의 컨트롤 데이터를 관리

데이터 애셋의 구성과 적용
 각 섹션별로 데이터를 저장
  Pawn 카테고리
  캐릭터무브먼트 카테고리
  입력 카테고리
  스프링암 카테고리
 Pawn과 캐릭터무브먼트 데이터는 CharacterBase에서 설정
 입력과 스프링암 데이터는 CharacterPlayer에서 설정
  
뷰의 변환
 컨트롤을 변경할 때 서로 다른 입력 매핑 콘텍스트를 지정
 숄더뷰 : ShoulderMove와 ShouderLook을 사용
 쿼터뷰 : QuaterMove만 사용
 입력 액션을 사용해 변경

=== <쿼터뷰/숄더뷰 전환 영상 확인 >

캐릭터 컨트롤 설정과 구현
 1. 컨트롤러에 설정된 ControlRotation 속성의 이해
 2. 캐릭터의 움직임과 회전을 설정하는 다양한 구성 요소와 설정 값의 이해
 3. 입력 매핑 콘텍스트를 활용한 뷰의 변환 구현

====================================

4강

캐릭터 애니메이션 설정
 캐릭터의 애니메이션 시스템을 생성하는 방법의 학습 
 캐릭터의 애님에이션 시스템을 효과적으로 설계하는 방법의 학습

SK_Mannequin_Skeleton - 이 것을 중심으로 애니메이션 설정

캐릭터 애니메이션 시스템의 생성
 스켈레탈 메시 컴포넌트의 애니메이션 블루프린트 클래스를 지정한다.
 캐릭터가 초기화될 때 AnimInstance 클래스의 인스턴스를 생성한다.
 캐릭터는 GetAnimInstance 함수를 사용해 애니메이션 인스턴스를 얻을 수 있음
 애니메이션 인스턴스는 GetOwningActor 함수를 사용해 자신을 소유한 액터 정보를 얻을 수 있음

캐릭터 애니메이션 시스템의 설계
 애니메이션 블루프린트는 이벤트 그래프와 애님 그래프의 두 영역으로 구성되어 있음
 이벤트 그래프에서는 이벤트로부터 상태를 파악할 수 있는 주요 변수를 저장하는데 사용
 애님 그래프에서는 저장된 변수로부터 지정된 상태의 애니메이션을 재생
 애님 그래프의 복잡한 상태는 State Alias로 분리해 효과적으로 설계할 수 있음

=== <블루 프린트 애니메이터 컨트롤 방법 영상 확인> ===

====================================

5강

캐릭터 콤보 액션
 애니메이션 몽타주 시스템의 활용 방법
 데이터 애셋과 델리게이트를 활용한 콤보 공격의 구현

애니메이션 몽타주
 몽타주 : 이미지 일부를 잘라내 한 화면에서 합성하는 회화 기법
 애니메이션 클립을 잘라내고 합성한 후 이를 재생하는 애니메이션 기능
 애니메이션 클립을 모아둔 다수의 섹션으로 구성되어 있음
 섹션끼리 연동할 수 있으며, 스크립트를 통해 원하는 섹션으로 건너뛸 수 있음

콤보 공격의 기획
 콤보 정보를 저장한 데이터 애셋의 생성 (ArenaBattleCombo)
 각 콤보마다 입력을 테스트하는 프레임을 지정 (마지막 프레임 제외)
 테스트 프레임 전에 입력이 들어오면 몽타주 섹션으로 이어서 재생
 테스트 프레임보다 입력이 늦으면 해당 섹션을 마저 플레이하고 종료

애니메이션 몽타주와 콤보 공격의 구현
 애니메이션 몽타주 활용 방법의 이해
 데이터 애셋을 활용한 콤보 로직의 구현
 언리얼 델리게이트를 사용한 이벤트 콜백의 구현

====================================

6강

캐릭터 공격 판정
충돌 판정 기능을 활용한 캐릭터의 공격 구현
강의목표
 애니메이션 이벤트 발생을 위한 노티파이 설정 방법의 학습
 공격 판정을 위한 트레이스 채널 설정과 판정을 시각적으로 디버깅하는 방법의 학습
 데미지 프레임웍을 활용한 데미지 전달과 Dead 상태의 구현

캐릭터 액션의 충돌 판정
 월드가 제공하는 충돌 판정 서비를 사용
 월드는 크게 세 가지의 충돌 판정 서비스를 제공함
 월드 내 배치된 충돌체와 충돌하는지 파악하고, 충돌한 액터 정보를 얻을 수 있음.

트레이스 채널과 충돌 프로필 생성
 액션 판정을 위한 트레이스 채널의 생성 : ABAction. 기본 반응은 무시
 캐릭터 캡슐용 프로필 : ABAction 트레이스 채널에 반응. 오브젝트 타입은 Pawn
 스켈레탈 메시용 프로필 : 랙돌 구현을 위해 주로 활용됨.
 기믹 트리거용 프로필 : 폰 캡슐에만 반응하도록 설정. 오브젝트 타입은 WorldStatic 

월드 트레이싱 함수의 선택
 세 가지 카테고리로 원하는 함수 이름을 얻을 수 있음
 카테고리1 : 처리 방법
 카테고리2 : 대상
  Test : 무언가 감지되었는지를 테스트
  Single 또는 AnyTest : 감지된 단일 물체 정보를 반환
  Multi : 감지된 모든 물체 정보를 배열로 반환
 카테고리 3 : 처리 설정
  ByChannel : 채널 정보를 사용해 감지
  ByObjectType : 물체에 지정된 물리 타입 정보를 사용해 감지
  ByProfile : 프로필 정보를 사용해 감지

캐릭터 공격 판정의 구현
 캐릭터의 위치에서 시선 방향으로 물체가 있는지 감지
 작은 구체를 제작하고 시선 방향으로 특정 거리까지만 투사
 하나의 물체만 감지
 트레이스 채널을 사용해 감지

물리 충돌 테스트
 디버그 드로잉 함수를 사용해 물리 충돌을 시각적으로 테스트
 90도로 회전시킨 캡슐을 그리기
  Origin
  HalfHeight
  Radius


 




 




















