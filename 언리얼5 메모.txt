언리얼

1강

언리얼 C++
게임 framework 이해 

언리얼 자료구조, 메모리 관리, 에셋/빌드 시스템 이해

시작 : 
설치 옵션 - 디버깅을 위한 편집기 기호(설치)

https://vlasovstudio.com/visual-commander/ 
제일 하단에 라인 맞춰주는 툴 다운

언리얼 코드 컴파일 방법
헤더 파일 변경할 때는 에디터를 끄고 visual studio에서 컴파일한다.
소스 파일에만 변경 - 라이브 코딩으로 컴파일 (ctrl + alt + F11)
★ visual studio에서 수동으로 클래스 추가 금지! ★

UGameInstance - Init 함수 override
UE_LOG(LogTemp, Log, TEXT("%s"), TEXT("Hello Unreal!")); - (카테고리, Log, 텍스트 매크로)

Edit - ProjectSetting - Maps & Modes - Game Instance Class - 만들어 놓은 클래스 적용시키기 
Default Maps - 기본화면이 필요가 없으므로 Editor Startup Map, Game Default Map의 OpenWorld 설정을 None으로 설정 - 재시작 -> 빈화면

Window - output Log

=================================================

2강

언리얼 C++ 코딩 표준 
-> 개발자들끼리 통일성있는 규칙 이해

언리얼은 Pascal Casing 사용 (ex) UnrealEngine, 카멜, 스네이크 사용 X)

접두사
Unreal Object 상속 받는 것은 U 접두사 
Actor는 A
UI 전용 클래스 S
추상 인터페이스 I
bool형 변수는 소문자 b
일반 C++ 및 구조체는 F

변경되면 안되는 것에는 const 키워드 사용하기

가급적이면 적은 수의 헤더파일 사용하기 (#include 구문으로 인한 의존성 최소화 시키기)

더 이상 파생 시킬 클래스가 아니면 final로 잠궈주기

==============================================

3강

게임 제작의 특징
데이터 정보가 명확해야함
단일 컴퓨터에서 최대 퍼포먼스내야 함
네트워크 상에서 데이터 통신이 효율적이고 안정적이어야 함

헤더에는 가급적 bool 대신 uint8 타입을 사용하되 Bit Field 오퍼레이터를 사용
일반 uint8과 구분을 위해 b접두사 사용
 .cpp 로직에서는 자유롭게 사용

텍스트 포맷
ASCII, ANSI, UTF-8, UTF-16

UTF-16(2byte) 메모리 더사용 하지만 정렬된 데이터 사용 

기본적으로 언리얼에서 모든 스트링은 FString 또는 TCHAR 정렬 상태로 UTF-16 포맷 메모리에 저장됨.
소스코드에 한글 사용하겠다 하면 UTF-8 방식으로 저장하면 된다 하지만 여러문제가 생길 수있으므로 비추.

변환 루틴 
TCHAR_TO_ANSII(str)

[TCHAR <=> FString]
void UMyGameInstance::Init()
{
	Super::Init();

	TCHAR LogCharArray[] = TEXT("Hello Unreal");
	UE_LOG(LogTemp, Log, LogCharArray);

	FString LogCharString = LogCharArray;
	UE_LOG(LogTemp, Log, TEXT("%s"), *LogCharString);
}

FString에 문자열을 담으면 동적 배열(TArray)에 담겨져 있으므로 *로 가져온다.
 
FString에서 다른 타입으로의 변환(안전하지 않으므로 주의)
FCString::Atoi (ASCII to Integer)
FCString::Atof (ASCII to Float)

컴파일에 한글 나오도록 하는 방법
File - Save 파일.cpp As..  
save(아래 화살표) Encoding - UTF-8

FName : 에셋관리를 위해 사용되는 문자열 체계 (해시값(key, value)으로 빠르게 찾음)
대소문자 구분 없음
한번 선언되면 바꿀 수 없음
가볍고 빠름
문자 표현 용도가 아닌 에셋 키를 지정하는 용도로 사용, 빌드시 해시값으로 변환됨

FText : 다국어 지원을 위한 문자열 관리 체계
일종의 키로 작용
별도의 문자열 테이블 정보가 추가로 요구됨
게임 빌드 시 자동으로 다양한 국가별 언어로 변환됨

언리얼은 FName과 관련된 글로벌 Pool 자료구조를 가지고 있음
FName과 글로벌 Pool
 문자열이 들어오면 해시 값을 추출해 키를 생성해 FName에서 보관
 FName 값에 저장된 값을 사용해 전역 Pool에서 원하는 자료를 검색해 반환
 문자 정보는 대소문자를 구분하지 않고 저장함(Ignore Case)
FName의 형성
 생성자에 문자열 정보를 넣으면 풀을 조사해 적당한 키로 변환하는 작업이 수반됨
 Find or Add의 행동만 취함

FName이 하는 일은 문자열을 키로 변환한 다음 그 키가 전역 풀에 있는지 조사하는 작업을 해서 overhead 발생 가능성있음
=> 가급적이면 처음에 초기화할 때 한번만 데이터를 저장하도록 하기
for(int i =0; i < 10000, ++i)
{
 //두번째의 방법을 사용하기
 FName SearchInNamePool = FName(TEXT("pelvis"));
 const static FName StaticOnlyOnce(TEXT("pelvis"));
}

============================================

4강

게임 프로그래밍이 가지는 특수성, 언리얼 오브젝트의 필요성의 이해
언리얼 오브젝트의 선언과 엔진 내부 컴파일 과정의 학습

게임 프로그래밍의 특수성
사용자 : 쾌적한 경험을 위해 단일 컴퓨터에서 최대 성능을 뽑아 내야 한다.
개발자 : 게임의 규모가 커질수록 방대하고 복잡한 기능을 안정적으로 관리해야 한다.

언리얼은 아래 두가지 장점을 녹여냈다고 함
Native 접근 C++ 언어(안정성보다 성능 중시)
 메모리를 직접 제어
 Cache의 활용 극대화
 저수준  API의 직접 호출
 복사 작업의 최소화

하이레벨 OOP 언어(성능보다 안정성 중시)
 유지보수성 향상
 크래시로부터 보호
 자동 메모리 관리
 고질적 실수 예방

SOLID
Single reponsibility principle 
Open/Closed 
Liskov substituion 
Interface segregation
Dependency inversion

언리얼 엔진의 선택
 성능을 위해 기존C++ 사용
 기존 C++을 확장해 객체 지향 설계 가능하도록 만듬
=> 언리얼 C++
 메모리를 직접 제어
 Cache의 활용 극대화
 저수준 API의 직접 호출
 복사 작업의 최소화
 유지보수성 향상
 크래시로부터 보호
 자동 메모리 관리
 고질적 실수 예방

언리얼 오브젝트 
 언리얼 엔진이 설계한 새로운 시스템의 단위 오브젝트(객체)
  기존 C++ 오브젝트에 객체 지향 설계를 위한 다양한 기능을 추가한 오브젝트
  일반 C++ 오브젝트와 언리얼 오브젝트의 두 객체를 모두 사용할 수 있음.
  구분을 위해 일반 C++오브젝트는 F, 언리얼 오브젝트는 접두사 U를 사용

 각 오브젝트의 사용 용도
  C++ 오브젝트 : 저수준의 빠른 처리를 위한 기능 구현에 사용
  언리얼 오브젝트 : 콘텐츠 제작에 관련된 복잡한 설계 구현에 사용 

언리얼 오브젝트가 가지는 특징
 클래스 기본 객체(CDO) : 클래스의 기본 값과 타입 정보의 제공
 리플렉션(Reflection) : 런타임에서 클래스 정보의 참조 기능
 인터페이스(Interface) : 객체 지향 언어가 제공하는 인터페이스 제공
 향상된 열거형
 델리게이트(Deligate) : 객체간의 결합을 낮출 수 있는 델리게이트 기능 제공
 가비지컬렉션(GC) : 자동 메모리 관리
 향상된 구조체(Struct) : 리플렉션이 가능한 구조체의 지원
 직렬화(Serialization) : 객체 정보를 바이트 스트림으로 저장, 전송, 불러들이는 기능 

UNREALOBJECT_API 키워드
ex) 
UCLASS()
class UNREALOBJECT_API UMyObject : public UObject 
{
	GENERATED_BODY()
};
다른 곳에서도 해당 키워드가 있는 클래스를 사용할 수 있게 개방해줌
UNREALOBJECT_API가 없으면 다른 모듈에서 참조 불가, UObject 내에서만 사용 가능하게 됨

GENERATED_BODY()는 MyObject.generated.h 파일에 있으며 
변경 사항 적용하거나 파일을 지우고 빌드하면 UHT(Unreal Header Tool)에 의해 소스코드가 자동 생성이 됨
폴더 내부에 들어가 있는게 객체 지향 설계를 위한 것들을 자동으로 생성해주는 역할
내부에 깊숙히 있기 때문에 손대지 말라고 인지하고 있으면 됨

===========================================

5강

언리얼 오브젝트 리플렉션 시스템1
 언리얼 오브젝트의 특징과 리플렉션 시스템의 설명
 언리얼 오브젝트의 처리 방식의 이해

언리얼 프로퍼티 시스템(리플렉션)
리플렉션은 프로그램이 실행시간에 자기 자신을 조사하는 기능으로
언리얼 엔진 테크놀로지의 근간을 이루는 것
에디터의 디테일 패널, 직렬화, GC, 네트워크 리플리케이션, BP/C++ 커뮤니케이션 등
다수의 시스템에 탑재된 것 그러나 C++는 어떠한 리플렉션도 지원하지 않아서 언리얼에는 자체적으로
C++ 클래스, 구조체, 함수 , 멤버 변수, 열거형 관련 정보를 수집, 질의, 조작하는 별도의 시스템이 구축되어 있음

리플렉션된 프로퍼티가 아닌 것은 직접 메모리를 관리해줘야 한다.

프로퍼티 시스템에 대한 유형 계층구조
UField
	UStruct
		UClass (C++ class)
		UScriptStruct(C++ struct)
		UFunction(C++ fuction)
	UEnum(C++ enumeration)
	UProperty(C++ member variable or fuction parameter)


언리얼 오브젝트의 구성
 언리얼 오브젝트에는 특별한 프로퍼티와 함수를 지정할 수 있음.
  관리되는 클래스 멤버 변수 : UPROPERTY
  관리되는 클래스 멤버 함수 : UFUNCTION
  에디터와 연동되는 메타데이터를 심을 수 있음

 모든 언리얼 오브젝트는 클래스 정보와 함께 함
  클래스를 사용해 자신이 가진 프로퍼티와 함수 정보를 컴파일 타임과 런타임에서 조회할 수 있음.

 이렇게 다양한 기능을 제공하는 언리얼 오브젝트는 NewObjectAPI를 사용해 생성해야 함 


언리얼 클래스 정보에는 클래스 기본 오브젝트 CDO(Class Default Object)가 포함되어 있음
CDO는 언리얼 객체가 가진 기본 값을 보관하는 템플릿 객체
한 클래스로부터 다수의 물체를 생성해 게임 콘텐츠에 배치할 때 일관성 있게 기본 값을 조정하는데 유용하게 사용됨
CDO는 클래스 정보로부터 GetDefaultObject 함수를 통해 얻을 수 있음
UClass 및 CDO는 엔진 초기화 과정에서 생성되므로 콘텐츠 제작에서 안심하고 사용할 수 있음

헤더파일의 리플렉션 정보의 구조를 변경하거나 
생성자 코드에서 클래스 디폴트 오브젝트의 기본 값을 변경하는 경우에는 에디터를 끄고 컴파일해서 다시 실행하는 것이 안전

F9 : 브레이크 포인트

====================================

6강

언리얼 오브젝트 리플렉션 시스템2

★헤더파일 등록 할때★
generated.h 파일이 가장 아래에 존재하도록 해야함

.cpp 스크립트에서 헤더에 등록한 함수나 변수 찾지 못할 때에는 
해당 헤더파일로 가서 컴파일 해주면 generated.h 파일에 적용되어 찾아짐

cpp파일에 헤더 파일 추가 할 때
해당 언리얼 오브젝트에 선언된 헤더가 가장 위쪽에 있어야 컴파일 오류가 안남
=> 헤더 파일 추가할 때에는 기존에 존재하던것 아래에 추가해주면 됨

언리얼 오브젝트는 new키워드로 생성 X / NewObject<>()로 생성
ex) UStudent* Student = NewObject<UStudent>();

언리얼 리플렉션 시스템의 활용
 언리얼 오브젝트의 특적 속성과 함수를 이름으로 검색할 수 있다.
 접근 지시자와 무관하게 값을 설정할 수 있다.
 언리얼 오브젝트의 함수를 호출할 수 있다.

언리얼 엔진의 기본 프레임워크는 리플렉션을 활용해 구축되어 있으므로 
언리얼 엔진을 이해하기 위해서는 리플렉션 시스템을 이해하는 것이 필요함.

=========================================================

7강

언리얼 C++ 설계1 - Interface
인터페이스를 이용하여 보다 안정적으로 클래스 설계하기

ex)
월드에 배치되는 모든 오브젝트(안 움직이는 것 포함) ==> Actor
특수한 기능을 부여하고 싶을 때에는 Actor를 상속받은 Pawn이라는 클래스에 INavAgentInerface를 구현함

언리얼 C++ 인터페이스 특징
 인터페이스를 생성하면 두 개의 클래스가 생성됨
  U로 시작하는 타입 클래스
  I로 시작하는 인터페이스 클래스

 객체를 설계할 때 I 인터페이스 클래스를 사용
  U타입 클래스 정보는 런타임에서 인터페이스 구현 여부를 파악하는 용도로 사용됨. 
  실제로 U타입 클래스에서 작업할 일은 없음
  인터페이스에 관련된 구성 및 구현은 I 인터페이스 클래스에서 진행

 C++ 인터페이스 특징
  ★추상 타입으로만 선언할 수 있는 Java, C#과 달리 언리얼은 인터페이스에도 구현이 가능함. ★

스크립트 이주
파일명 - Source - 헤더, cpp 파일 복붙 - 언리얼 에디터 - Tools - Refresh Visual Studio 2022 Project 실행 - 프로젝트의 구성이 변경됨.

클래스 정보에 대해 단일 상속만 지원

언리얼 C++ 인터페이스
 클래스가 반드시 구현해야 하는 기능을 지정하는데 사용함.
 C++은 기본적으로 다중상속을 지원하지만, 언리얼 C++의 인터페이스를 사용해 가급적 축소된 다중상속의 형태로 구현하는 것이 향후 유지보수에 도움이 된다.
 언리얼 C++ 인터페이스는 두 개의 클래스를 생성한다.
 언리얼 C++ 인터페이스는 추상 타입으로 강제되지 않고, 내부에 기본 함수를 구현할 수 있다.
=> 언리얼 C++ 인터페이스를 사용하면, 클래스가 수행해야 할 의무를 명시적으로 지정할 수 있어 좋은 객체 설계를 만드는데 도움을 줄 수 있다.

===================================

8강 

언리얼 C++ 설계2 - Composition

언리얼 C++ 컴포지션 기법을 사용해 오브젝트의 포함 관계를 설계하는 방법의 학습
언리얼 C++이 제공하는 확장 열거형 타입의 선언과 활용 방법의 학습

컴포지션
 객체 지향 설계에서 상속이 가진 Is-A 관계만 의존해서는 설계와 유지보수가 어려움.
 컴포지션은 객체 지향 설계에서 Has-A 관계를 구현하는 설계 방법
 컴포지션의 활용 - 복합적인 기능을 거대한 클래스를 효과적으로 설계하는데 유용하게 사용할 수 있음.

언리얼 엔진에서의 컴포지션 구현 방법
 하나의 언리얼 오브젝트에는 항상 클래스 기본 오브젝트(CDO)가 있다.
 언리얼 오브젝트간 컴포지션은 어떻게 구현할 것인가?
 언리얼 오브젝트에 다른 언리얼 오브젝트를 조합할 때 다음의 선택지가 존재한다.
  방법 1 : CDO에 미리 언리얼 오브젝트를 생성해 조합 (CreateDefaultSubobject() API 사용)
  방법 2 : CDO에 빈 포인터만 넣고 런타임에서 언리얼 오브젝트를 생성해 조합 (NewObject() API 사용)
 언리얼 오브젝트를 생성할 때 컴포지션 정보를 구축할 수 있다.
  내가 소유한 언리얼 오브젝트를 Subobject라고 함
  나를 소유한 언리얼 오브젝트를 Outer라고 함
==> Subobject가 필수적으로 포함되어야 하는 것인지 아닌지 차이

열거형에는 접두사 E를 이용함, uint8은 열거형 사용할 때 일반적으로 쓰임
ex) 
UENUM()
enum class ECardType : uint8
{
	Student = 1 UMETA(DisplayName = "For Student"),
	Teacher UMETA(DisplayName = "For Teacher"),
	Staff UMETA(DisplayName = "For Staff"),
	Invalid
}

---- 언리얼 엔진5 마이그레이션 가이드 ---- 
UPROPERTY()
class UCard* Card;		    ----- 언리얼 4 방식

UPROPERTY()
TObjectPtr<class UCard> Card; ----- 언리얼 5 방식

열거형 데이터를 문자열로 출력
FString CardMetaData = CardEnumType->GetDisplayNameTextByValue((int64)CardType).ToString();
UE_LOG(LogTemp, Log, TEXT("%s님이 소유한 카드 종류 %s), *Person->GetName(), *CardMetaData);

컴포지션을 활용한 언리얼 오브젝트 설계
 언리얼 C++은 컴포지션을 구현하는 독특한 패턴이 있다.
 클래스 기본 객체를 생성하는 생성자 코드를 사용해 복잡한 언리얼 오브젝트를 생성할 수 있음.
 언리얼 C++ 컴포지션의 Has-A관계에 사용되는 용어
  내가 소유한 하위 오브젝트 : Subobject
  나를 소유한 상위 오브젝트 : Outer
언리얼 C++이 제공하는 확장 열거형을 사용해 다양한 메타 정보를 넣고 활용할 수 있다.

================================================

9강

언리얼 C++설계3 - 델리게이트 (클래스간 느슨한 결합 구현하기)

느슨한 결합의 장점과 이를 편리하게 구현하도록 도와주는 델리게이트의 이해
발행 구독 디자인 패턴의 이해
언리얼 델리게이트를 활용한 느슨한 결합의 설계와 구현

C#의 delegate 키워드
 함수를 객체처럼 다룰 수 있음
 안정적이고 간편한 선언
C++도 delegate를 지원함
 느슨한 결합 구조를 간편하고 안정적으로 구현할 수 있음

발행 구독 디자인 패턴이란
 푸시(Push) 형태의 알림(Notification)을 구현하는데 적합한 디자인 패턴
 발행자(Publisher)와 구독자(Subscriber)로 구분된다.
  콘텐츠 제작자는 콘텐츠를 생삲나다.
  발행자는 콘텐츠를 배포한다.
  구독자는 배포된 콘텐츠를 받아 소비한다.
  제작자와 구독자가 서로 몰라도, 발행자를 통해 콘텐츠를 생산하고 전달할 수 있다.(느슨한 결합)

 발행 구독 디자인 패턴의 장점
  제작자와 구독자는 서로를 모르기 때문에 느슨한 결합으로 구성된다.
  유지 보수가 쉽고 유연하게 활용될 수 있으며, 테스트가 쉬워진다.
  시스템 스케일을 유연하게 조절할 수 있으며, 기능 확장이 용이하다.

언리얼 델리게이트(Delegate)
 언리얼 엔진은 발행 구독 패턴 구현을 위해 델리게이트 기능을 제공함.
  
언리얼 델리게이트 선언시 고려사항
 어떤 데이터를 전달하고 받을 것인가? 인자의 수 와 각각의 타입을 설계
  몇 개의 인자를 전달할 것인가?
  어떤 방식으로 전달할 것인가?
  1:1 ? 
  1: 다수?
	
 프로그래밍 환경 설정
  C++ 프로그래밍에서만 사용할 것인가?
  UFUNCTION으로 지정된 블루프린트 함수와 사용할 것인가?

 어떤 함수와 연결할 것인가?
  클래스 외부에 설계된 C++함수와 연결
  전역에 설계된 정적 함수와 연결
  언리얼 오브젝트의 멤버 함수와 연결(대부분의 경우에 이 방식을 사용)

델리게이트 선언 매크로
 DECLARE_{델리게이트유형}DELEGATE{함수정보}
  일대일 형태로 C++만 지원한다면 유형은 공란으로 둔다.       		 => DECLARE_DELEGATE
  일대다 형태로 C++만 지원한다면 MULTICAST를 선언한다.        		 => DECLARE_MULTICAST
  일대일 형태로 블루프린트를 지원한다면 DYNAMIC을 선언한다. 		 => DECLARE_DYNAMIC
  일대다 형태로 블루프린트를 지원한다면 DYNAMIC과 MULTICAST를 조합한다. => DECLARE_DYNAMIC_MULTICAST

 함수 정보 : 연동 될 함수 형태를 지정한다.
  인자가 없고 반환값도 없으면 공란으로 둔다.			=> DECLARE_DELEGATE
  인자가 하나고 반환값이 없으면 OneParam으로 지정한다.  	=> DECLARE_DELEGATE_OneParam
  인자가 세 개고 반환값이 있으면 RetVal_ThreeParams로 지정한다   =>  DECLARE_DELEGATE_RetVal_ThreeParams (MULTICAST는 반환값을 지원하지 않음)
  최대 9개까지 지원함.

매크로 선정 예시
 학사 정보가 변경되면 알림 주체와 내용을 학생에게 전달한다.
 => 두개의 인자를 가짐
 변경된 학사 정보는 다수 인원을 대상으로 발송한다.
 => MULTICAST를 사용
 오직 C++ 프로그래밍에서만 사용한다.
 => DYNAMIC은 사용하지 않음
[DECLARE_MULTICAST_DELEGATE_TwoParams 매크로 사용]

======================================

10강

언리얼 컨테이너 라이브러리1 - Array와 Set

언리얼 대표 컨테이너 라이브러리, Tarray, TSet 내구 구조 이해
각 컨테이너 라이브러리의 장단점을 파악 및 활용하는 방법 학습

언리얼 컨테이너 라이브러리(UCL : Unreal Container Library)
 언리얼 엔진이 자체 제작해 제공하는 자료구조 라이브러리
 언리얼 오브젝트를 안정적으로 지원하며 다수 오브젝트 처리에 유용하게 사용됨
 언리얼 C++은 다양한 자료구조 라이브러리를 직접 만들어 제공하고 있음
 실제 게임 제작에 유용하게 사용되는 라이브러리로 세 가지를 추천
 => TArray, TMap, TSet

C++ STL과 언리얼 컨테이너 라이브러리의 차이점
 C++ STL :
  범용적으로 설계되어 있다.
  표준이기에 호환성이 높다.
  많은 기능이 엮여 있어 컴파일 시간이 오래걸림.

 언리얼 컨테이너 라이브러리 : 
  언리얼 엔진에 특화되어 있음
  언리얼 오브젝트 구조를 안정적으로 지원한다.
  가볍고 게임 제작에 최적화되어 있음

두 라이브러리의 이름과 용도는 유사하지만, 내부적으로 다르게 구현되어 있음
 TArray : 오브젝트를 순서대로 담아 효율적으로 관리하는 용도로 사용
 TSet : 중복되지 않는 요소로 구성된 집합을 만드는 용도로 사용
 TMap : key, value 조합의 레코드를 관리하는 용도로 사용

TArray 개요
 TArray는 가변 배열(Dynamic) 자료구조
 STL의 vector와 동작 원리가 유사함.
 게임 제작에서는 가변 배열 자료7구조를 효과적으로 활용하는 것이 좋음.
  데이터가 순차적으로 모여있기 때문에 메모리를 효과적으로 사용할 수 있고 캐시 효율이 높다.
  컴퓨터 사양이 좋아지면서, 캐시 지역성(Locality)으로 인한 성능 향상은 굉장히 중요해짐.
  임의 데이터의 접근이 빠르고, 고속으로 요소를 순회하는 것이 가능

 가변 배열의 단점 
  맨 끝에 데이터를 추가하는 것은 가볍지만, 중간에 요소를 추가하거나 삭제하는 작업은 비용이 큼
 
 데이터가 많아질수록 검색, 삭제, 수정 작업이 느려지기 때문에, 
 많은 수의 데이터에서 검색 작업이 빈번하게 일어난다면 TArray 대신 TSet을 사용하는 것이 좋음

TArray는 값 유형으로 int32나 float 같은 다른 내장형과 비슷하게 취급해야 합니다. 
확장을 염두에 두지는 않았기에, TArray 인스턴스를 new 및 delete로 생성 또는 소멸시키는 것은 좋지 않습니다. 
=> 동적 할당을 하지 않는다.

다른 TArray 변수에서 TArray 변수를 만들면 그 엘리먼트를 새 변수에 복사하며, 공유되는 상태는 없습니다.

ex) (TArray - Add, Emplace)
TArray<FString> StrArr;
StrArr.Add	(TEXT("Hello"));
StrArr.Emplace	(TEXT("World"));
// StrArr == ["Hello","World"]

Add(또는 Push)는 엘리먼트 유형의 인스턴스를 배열에 복사(또는 이동)합니다.
Emplace는 지정한 인수를 사용하여 엘리먼트 유형의 인스턴스를 새로 생성합니다. (TArray에서 자체적으로 생성)
=> Emplace가 조금 더 효율적
=> 복사하는 불필요한 절차를 피할 수 있기 때문
=> Emplace가 Add보다 효율이 떨어질 일은 절대 없지만, 가독성은 Add가 나을 수도 있습니다.

Append : 한번에 다수의 객체를 넣을 때 사용 (operator += 으로 배열 연결 가능)
AddUnique : 기존 컨테이너에 동일한 엘리먼트가 존재하지 않는 경우 새 엘리먼트만 추가
Insert : 주어진 인덱스에 추가 
=> 전체적인 메모리 구조가 변경될 수 있음 (비용이 발생)
SetNum : 언리얼에서는 Count X, Num 사용

for문, 컨테이너 등에 const 키워드 사용하게되면 읽기 전용 순회가 됨

GetData : 배열 내 엘리먼트에 대한 포인터를 반환시킬 수 있습니다.

유효하지 않은 인덱스는 Num() 또는 IsValidIndex함수를 통해 체크

operator[] 는 레퍼런스를 반환하므로, 배열이 const가 아니라면 배열 내의 엘리먼트 변환 가능

Top, Last 함수 : 동의어로 인덱스를 받지 않는 다는 점이 다릅니다.
(Last함수를 사용하여 배열 끝에서부터 역순으로 인덱스를 사용할 수도 있습니다.)
ex)
FString ElemEnd = StrArr.Last();
FString ElemEnd0 = StrArr.Last(0);
FString ElemEnd1 = StrArr.Last(1);
FString ElemTop = StrArr.Top();

Contains : 특정 엘리먼트 있는지 확인

Find : 모든 요소를 순회할 경우도 있기에 효율이 좋지 않음
=> 엘리먼트를 찾지 못했으면 특수 INDEX_NONE 값이 반환됨.

빠르게 검색하고 싶다면 Set 컨테이너 사용하는 것이 좋음

Remove : Insert와 마찬가지로 배열에 엘리먼트를 제거 할때 전체적인 데이터 변동이 일어나서 효율이 좋지 않음
RemoveAt : 해당 요소 제거
RemoveAll : 모든 요소 제거 
ex) 3의 배수인 값을 전부 제거하는 RemoveAll 사용할 때
★엘리먼트가 제거되는 모든 경우 그 뒤의 엘리먼트가 낮은 인덱스로 정리가 되므로, 배열에는 절대 '구멍'이 생길 수 없습니다.★

정리 프로세스에는 비용이 따름
=> RemoveSwap, RemoveAtSwap, RemoveAllSwap 함수로 부하를 줄일 수 있으나 ★Set 컨테이너 써라.★

Empty : 배열에서 모든 것을 제거합니다.

operator ==, != : 
엘리먼트의 수와 순서가 같은 경우만 true 판정 
FString은 대소문자 구별하지 않기에 위의 조건이라면 true 판정

힙

슬랙(Slack) : 여유분, 배열이 추가 될 때 매번 재할당을 피하기 위해 요청한 것보다 넉넉한 메모리를 제공하여 퍼포먼스 비용을 물지 않도록 함
GetSlack : 배열의 슬랙 크기가 얼마나 되는지 알아낼 수 있음

AddUninitialized, InsertUninitialized 함수 :
 각각 Add, Insert처럼 작동 하지만 해당 엘리먼트 유형의 생성자를 호출하지는 않습니다.
 ex) Memcpy 호출로 전체 구조체를 덮어쓰려는 경우처럼 생성자 호출을 피할 때 좋습니다.


TSet의 특징
 STL의 set과 언리얼 TSet의 비교
  STL set 특징
   이진 트리로 구성되어 있어 정렬을 지원함
   메모리 구성이 효율적이지 않음
   요소가 삭제될 때 균형을 위한 재구축이 일어날 수 있음
   모든 자료를 순회하는데 적합하지 않음.
 언리얼 TSet 특징
  해시테이블 형태로 키 데이터가 구축되어 빠른 검색이 가능
  동적 배열의 형태로 데이터가 모여있음
  데이터를 빠르게 순회할 수 있음
  삭제해도 재구축이 일어나지 않음
  비어있는 데이터가 있을 수 있음
==> 활용 방법이 서로 다르기 때문에 주의
==> STL의 unordered_set과 유사하게 동작하지만 동일하진 않음
==> TSet은 중복 없는 데이터 집합을 구축하는데 유용하게 사용할 수 있음.

언리얼5 도큐먼트 :
https://docs.unrealengine.com/5.1/ko/set-containers-in-unreal-engine/

TSet은 순서가 중요치 않은 상황에서 고유 엘리먼트를 저장하는 데 사용되는 고속 컨테이너 클래스입니다.
데이터에 구멍이 있을 수 있으나 추가되는 엘리먼트가 그 간극을 메꿈

데이터를 지우면 이빠진 데이터 공간이 남고 Add에서 데이터를 추가하게 되면
가장 나중에 없어진 부분부터 데이터가 채워짐 
==> TSet은 순번을 생각하지 않고 무작위 집합체로 인지하면 됨.

	TArray vs TSet
접근       O(1)       O(1)
검색       O(N)      O(1)
삽입       O(N)      O(1)
삭제       O(N)      O(1)
==> TArray는 메모리 빈틈없이 고속으로 빠르게 접근할 때 좋음
==> TSet은 빠르게 중복 감지하는데에 좋음

=======================================

11강 

언리얼 컨테이너 라이브러리2 - 구조체와 Map

언리얼 구조체의 선언과 특징 이해
언리얼 대표 컨테이너 라이브러리 TMap의 내부 구조 이해
세 컨테이너(TArray, TSet, TMap) 라이브러리의 장단점을 파악하고, 알맞게 활용하는 방법의 학습

언리얼 구조체 구현하기
 1. 구조체를 정의하려는 헤더(.h) 파일을 엽니다.
 2. C++ 구조체를 정의하고 앞에 USTRUCT 매크로를 추가.
 3. 구조체 상단에 GENERATED_BODY 매크로 추가
 4. 구조체의 멤버 변수를 UPROPERTY로 태그하여 언리얼 엔진의 리플렉션 시스템과 블루프린트 스크립팅에 표시할 수 있습니다.

구조체 사용시 알아두면 유용한 힌트
 1. UStructs는 언리얼 엔진의 포인터를 이용해 멤버 변수로 사용할 수 있는데 이때 UPROPERTY 매크로를 사용해야 GC에 의해 UObjects가 제거되는 것을 방지할 수 있음
 2. 구조체는 단순한 데이터 타입에 적합하므로 UObjects와는 다릅니다. 
 => 복잡한 인터랙션을 하기 위해서는 구조체보다는 UObject 또는 AActor 서브 클래스를 만드는 것이 좋습니다.
 3. UStructs는 리플리케이션용으로 간주되지 않습니다. UProperty 변수는 리플리케이션용으로 간주 됩니다.
 4. 구조체를 위한 Make, Break 함수 자동 생성 기능이 있습니다.
 => 에디터에 사용하는 기능들을 언리얼 구조체의 C++를 통해 제공할 수 있다.

언리얼 구조체 UStruct 
 데이터 저장/전송에 특화된 가벼운 객체
 대부분 GENERATED_BODY 매크로를 선언해준다.
  리플렉션, 직렬화와 같은 유용한 기능을 지원함
   GENERATED_BODY를 선언한 구조체는 UScriptStruct 클래스로 구현됨.
   이 경우 제한적으로 리플렉션을 지원함
    속성 UPROPERTY만 선언할 수 있고 함수 UFUNCTION은 선언할 수 없음
 언리얼 엔진의 구조체 이름은 F로 시작
  대부분 힙 메모리 할당(포인터 연산)없이 스택 내 데이터로 사용됨
  NewObject API를 사용할 수 없음

구조체는 언리얼 오브젝트가 아니기 떄문에 New API로 생성될 일이 없음

언리얼 오브젝트 포인터를 멤버변수로 가진다면 UPROPERTY 매크로를 반드시 넣어줘야함
그 외에 사용할 때에는 분명한 목적이 있어야한다 ex) 리플렉션을 통해 보여준다던지, 블루프린트 연동

언리얼 오브젝트 헤더에서 언리얼 오브젝트 포인터를 선언할 때에는 <TObjectPtr> 로 감싸줘야함
ex) TArray<TObjectPtr<class UStudent>> Students; 
★포인터를 관리하게 될 때에는 반드시 언리얼 엔진이 자동으로 관리할 수 있도록 
UPROPERTY 매크로를 해줘야함 (필수)★
==> 
UPROPERTY()
TArray<TObjectPtr<class UStudent>> Students; 

TMap의 구조와 활용
 STL map과 TMap의 비교
  STL map의 특징
   STL map은 STL set과 동일하게 이진 트리로 구성되어 있음
   정렬은 지원하지만, 메모리 구성이 효율적이지 않으며, 데이터 삭제시 잭축이 일어날 수 있음
   모든 자료를 순회하는데 적합하진 않음
  언리얼 TMap의 특징
   key, value 구성의 튜플(Tuple) 데이터의 TSet구조로 구현되어 있음
   해시테이블 형태로 구축되어 빠른 검색 가능
   동적 배열의 형태로 데이터가 모여있음
   데이터는 빠르게 순회할 수 있음
   데이터는 삭제해도 재구축이 일어나지 않음
   비어있는 데이터가 있을 수 있음
   TMultiMap을 사용하면 중복 데이터를 관리할 수 있음
 동작 원리는 STL unordered_map과 유사함
 Key, Value 쌍이 필요한 자료구조에 광범위하게 사용됨.

언리얼 TMap과 TSet은 유사하지만 TMap은 기본적으로 TPair<Key, Value>를 기본적으로 채택함
=> TSet을 TPair<Key, Value>로 구성한 것이 TMap

TMap은 TArray 다음으로 가장 많이 사용되는 컨테이너입니다.

TMap은 중복 허용하지 않고 TMultiMap은 중복을 허용함
=> 기존 것과 일치하는 새로운 Key-Value 대체될지(TMap), 새롭게 추가될지(TMultiMap) 차이가 있음 

맵에 키가 있는지 확인 할 때 Contains 함수에 operator []를 사용하면 되는데 불러오기에 성공해도 같은 키를 두번 조회한다.
=> Find함수는 한번의 조회로 끝 Find는 맵에 키가 있으면 엘리멘트 값으로의 포인터를, 없으면 null 포인터를 반환
ex)
FString* Ptr7 = FruitMap.Find(7);
FString* Ptr8 = FruitMap.Find(8);
// *Ptr7 == "Pineapple"
// Ptr8 == nullptr

FindOrAdd : 찾고 없으면 추가  

FindKey : 편리하게 쓰는 용도 성능은 안좋음

TArray처럼 TMap은 기본적으로 복사 생성을 통해 연산이 진행

슬랙(Slack) : 여유분, TSet과 동일, 끝 부분의 Slack을 제거하려면 Shrink 함수를 사용하면 됨

================================================

12강

언리얼 엔진의 메모리 관리
 언리얼 엔진의 메모리 관리 방식을 파악하고, 언리얼 오브젝트의 메모리를 관리하는 예제 실습

언리얼 엔진의 메모리 관리 시스템의 이해
안정적으로 언리얼 오브젝트 포인터를 관리하는 방법의 학습

C++ 언어 메모리 관리의 문제점
 C++은 저수준으로 메모리 주소에 직접 접근하는 포인터를 사용해 오브젝트를 관리한다.
 그러다보니 프로그래머가 직접 할당(new)과 해지(delete) 짝 맞추기를 해야 함
 잘못된 포인터 사용 예시
  메모리 누수(Leak) : new를 했는데 delete짝을 맞추지 못함. 힙에 메모리가 그대로 남아있음
  허상(Dangling) 포인터 : (다른 곳에서) 이미 해제해 무효화된 오브젝트의 주소를 가리키는 포인터
  와일드(Wild) 포인터 : 값이 초기화되지 않아 엉뚱한 주소를 가리키는 포인터
 잘못된 포인터 값은 다양한 문제를 일으키며, 한 번의 실수는 프로그램을 종료시킴
 게임 규모가 커지고 구조가 복잡해질수록 프로그래머가 실수할 확률을 크게 증가함
==> C++ 이후 나온 언어 Java/C#은 이런 고질적인 문제를 해결하기 위해 포인터를 버리고 GC 시스템 도입

가비지 컬렉션 시스템
 프로그램에서 더 이상 사용하지 않는 오브젝트를 자동으로 감지해 메모리를 회수하는 시스템
 동적으로 생성된 모든 오브젝트 정보를 모아둔 저장소를 사용해 사용되지 않는 메모리를 추적
 Mark-Sweep 방식의 가비지 컬렉션
  1. 저장소에서 최초 검색을 시작하는 루트 오브젝트를 표기한다.
  2. 루트 오브젝트가 참조하는 객체를 찾아 마크(Mark)한다.
  3. 마크된 객체로부터 다시 참조하는 객체를 찾아 마크하고 이를 계속 반복한다.
  4. 저장소에는 마크된 객체, 마크되지 않은 객체 두 그룹으로 나뉜다.
  5. 가비지 컬렉터가 저장소에서 마크되지 않은 객체(가비지)들의 메모리를 회수한다.(Sweep)

언리얼 엔진의 가비지 컬렉션 시스템
 Mark-Sweep 방식의 가비지컬렉션 시스템을 자체적으로 구축함
 지정된 주기마다 몰아서 없애도록 설정되어 있음 (GCCycle. 기본 값 60초)
 성능 향상을 위해 병렬 처리, 클러스터링과 같은 기능을 탑재함.

가비지 컬렉션을 위한 객체 저장소
 관리되는 모든 언리얼 오브젝트의 정보를 저장하는 전역 변수 : GUObjectArray
 GUObjectArray의 각 요소에는 플래그(Flag)가 설정되어 있음
 가비지 컬렉터가 참고하는 주요 플래그
  Garbage 플래그 : 다른 언리얼 오브젝트로부터의 참조가 없어 회수 예정인 오브젝트
  RootSet 플래그 : 다른 언리얼 오브젝트로부터 참조가 없어도 회수하지 않는 특별한 오브젝트

가비지 컬렉터의 메모리 회수
 가비지 컬렉터는 지정된 시간에 따라 주기적으로 메모리를 회수한다.(기본 값 60초)
 Garbage 플래그로 설정된 오브젝트를 파악하고 메모리를 안전하게 회수함.
 Garbage 플래그 수동으로 설정하는 것이 아닌, 시스템이 알아서 설정함.
 [한번 생성된 언리얼 오브젝트는 바로 삭젝자 불가능함]
★한번 생성된 오브젝트를 삭제하기 위해서는 레퍼런스 정보를 없애므로써 GC가 작동하도록 하는 것★

RootSet 플래그의 설정
 AddToRoot 함수를 호출해 루트셋 플래그를 설정하면 최초 탐색 목록으로 설정됨.
 루트셋으로 설정된 언리얼 오브젝트는 메모리 회수로부터 보호받음.
 RemoveFromRoot 함수를 호출해 루트셋 플래그를 제거할 수 있음.
[콘텐츠 관련 오브젝트에 루트셋을 설정하는 방법은 권장되지 않음]

언리얼 오브젝트를 통한 포인터 문제의 해결
 메모리 누수 문제
  언리얼 오브젝트는 GC를 통해 자동으로 해결
  C++ 오브젝트는 직접 신경써야 함(스마트 포인터 라이브러리의 활용)
 댕글링 포인터 문제
  언리얼 오브젝트는 이를 탐지하기 위한 함수를 제공함 (IsValid)
  C++ 오브젝트는 직접 신경써야 함(스마트 포인터 라이브러리의 활용)
 와일드 포인터 문제
  언리얼 오브젝트에 UPROPERTY 속성을 지정하면 자동으로 nullptr로 초기화 해 줌
  C++ 오브젝트의 포인터는 직접 nullptr로 초기화 할 것 (또는 스마트 포인터 라이브러리의 활용)

회수되지 않는 언리얼 오브젝트
 언리얼 엔진 방식으로 참조를 설정한 언리얼 오브젝트
  UPROPERTY로 참조된 언리얼 오브젝트 (대부분의 경우 이를 사용)
  AddReferencedObject 함수를 통해 참조를 설정한 언리얼 오브젝트
 루트셋(RootSet)으로 지정된 언리얼 오브젝트
[오브젝트 선언의 기본 원칙 : 오브젝트 포인터는 가급적 UPROPERTY로 선언, 메모리는 GC가 자동으로 관리하도록 위임]

일반 클래스에서 언리얼 오브젝트를 관리하는 경우
 UPROPERTY를 사용하지 못하는 일반 C++클래스가 언리얼 오브젝트를 관리해야 하는 경우
 FGCObject 클래스를 상속 받은 후 AddReferencedObjects 함수를 구현한다.
 함수 구현 부에서 관리할 언리얼 오브젝트를 추가해 줌.
 
언리얼 오브젝트의 관리 원칙
 생성된 언리얼 오브젝트를 유지하기 위해 레퍼런스 참조 방법을 설계할 것
  언리얼 오브젝트 내의 언리얼 오브젝트 : UPROPERTY 사용
  일반 C++ 오브젝트 내의 언리얼 오브젝트 : FGCObject의 상속 후 구현
 생성된 언리얼 오브젝트는 강제로 지우려 하지 말 것
  참조를 끊는다는 생각으로 설계할 것
  가비지 컬렉터에게 회수를 재촉할 수는 있음(ForceGarbageCollection 함수)
  콘텐츠 제작에서 Destroy함수를 사용할 수는 있으나, 결국 내부 동작은 동일함.(가비지 컬렉터에 위임)

메모리가 유효한지 체크해주는 IsValid
같은 것이지만 null 체크가 되어 있어 더 안정적인 IsValidLowLevel

null포인터로만 유효여부를 판단할 수는 없음 (댕글링 포인터 때문에) => UPROPERTY() 매크로 사용해서 댕글링 포인터의 문제에서 벗어나기

=================================================

13강 

언리얼 오브젝트 관리1 - 직렬화
 언리얼 엔진이 제공하는 직렬화 기능을 이해하고 언리얼 오브젝트의 데이터를 저장하고 불러들이기

직렬화(Serialization)란?
 오브젝트나 연결된 오브젝트의 묶음을 바이트 스트림으로 변환하는 과정
  복잡한 데이터를 일렬로 세우기 때문에 직렬화
 거꾸로 복구시키는 과정도 포함해서 의미
  Serialization : 오브젝트 그래프에서 바이트 스트림으로
  Deserialization : 바이트 스트림에서 오브젝트 그래프로
 직렬화가 가지는 장점
  현재 프로그램의 상태를 저장하고 필요할 때 복원할 수 있다. (게임의 저장)
  현재 객체의 정보를 클립보드에 복사해서 다른 프로그램에 전송할 수 있다.
  네트워크를 통해 현재 프로그램의 상태를 다른 컴퓨터에 복원할 수 있다.(멀티플레이어 게임)
  데이터 압축, 암호화를 통해 데이터를 효율적이고 안전하게 보관할 수도 있음

직렬화 구현시 고려할 점
 데이터 레이아웃 : 오브젝트가 소유한 다양한 데이터를 변환할 것인가?
 이식성 : 서로 다른 시스템에 전송해도 이식될 수 있는가?
 버전 관리 : 새로운 기능이 추가될 때 이를 어떻게 확장하고 처리할 것인가?
 성능 : 네트워크 비용을 줄이기 위해 어떤 데이터 형식을 사용할 것인가?
 보안 : 데이터를 어떻게 안전하게 보호할 것인가?
 에러 처리 : 전송 과정에서 문제가 발생할 경우 이를 어떻게 인식하고 처리할 것인가?

언리얼 엔진의 직렬화 시스템
 언리얼 엔진은 이러한 상황을 모두 고려한 직렬화 시스템을 자체적으로 제공하고 있음
 직렬화 시스템을 위해 제공하는 클래스 FArchive와 연산자
  아카이브 클래스(FArchive)
  Shift(<<) operator
 다양한 아카이브 클래스의 제공
  메모리 아카이브 (FMemoryReader, FMemoryWriter)
  파일 아카이브 (FArchiveFileReaderGeneric, FArchiveFileWriterGeneric)
  기타 언리얼 오브젝트와 관련된 아카이브 클래스(FArchiveUObject)
 Json 직렬화 기능 : 별도의 라이브러리를 통해 제공하고 있음

=== {직렬화 부분 영상 보기} ===

Json(JavaScript Object Notation) 직렬화
 웹 환경에서 서버와 클라이언트 사이에 데이터를 주고받을 때 사용하는 텍스트 기반 데이터 포맷
 Json 장점
  텍스트임에도 데이터 크기가 가벼움
  읽기 편해서 데이터를 보고 이해할 수 있음
  사실상 웹 통신의 표준으로 널리 사용됨
 Json 단점
  지원하는 타입이 몇 가지 안됨 (문자, 숫자, 불리언, 널, 배열, 오브젝트만 사용 가능)
  텍스트 형식으로만 사용할 수 있음
[언리얼 엔진의 Json, JsonUtilities 라이브러리 활용]

Json 데이터 예시
 Json 데이터 유형
  오브젝트 : {}
   오브젝트 내 데이터는 key, value 조합으로 구성됨 {"key" : 10}
  배열 : []
   배열 내 데이터는 value로만 구성 됨 ["value1", "value2", "value3"]
  이외 데이터
   문자열("string"), 숫자(10 또는 3.14), 불리언(true / false), 널(null)로 구성 

언리얼 스마트 포인터 라이브러리 개요
 일반 C++ 오브젝트의 포인터 문제를 해결해주는 언리얼 엔진의 라이브러리
 TUniquePtr(유니크포인터) : 지정한 곳에서만 메모리를 관리하는 포인터.
  특정 오브젝트에게 명확하게 포인터 해지 권한을 주고 싶은 경우
  delete 구문 없이 함수 실행 후 자동으로 소멸시키고 싶을 때
 TSharedPtr(공유포인터) : 더 이상 사용되지 않으면 자동으로 메모리를 해지하는 포인터
  여러 로직에서 할당된 오브젝트가 공유해서 사용되는 경우
  다른 함수로부터 할당된 오브젝트를 Out으로 받는 경우
  Null 일 수 있음
 TSharedRef(공유레퍼런스) : 공유포인터와 동일하지만, 유효한 객체를 항상 보장받는 레퍼런스
  여러 로직에서 할당된 오브젝트가 공유해서 사용되는 경우
  Not Null을 보장받으며 오브젝트를 편리하게 사용하고 싶은 경우

{Json 영상 보기}

====================================

14강

언리얼 오브젝트 관리2 - 패키지
 언리얼 엔진의 패키지와 애셋 개념을 이해하고 언리얼 에디터에 애셋 데이터를 저장하고 불러들이기

언리얼 엔진의 애셋과 이를 포장한 패키지의 개념 이해
언리얼 에디터에서 볼 수 있도록 애셋을 저장하고 불러들이는 방법의 이해
오브젝트 패스를 사용해 다양한 방식으로 애셋을 로딩하는 방법의 이해

언리얼 오브젝트 패키지
 단일 언리얼 오브젝트가 가진 정보는 저장할 수 있지만, 오브젝트들이 조합되어 있다면?
  저장된 언리얼 오브젝트 데이터를 효과적으로 찾고 관리하는 방법은?
  복잡한 계층 구조를 가진 언리얼 오브젝트를 효과적으로 저장과 불러들이는 방법을 통일해야 함
 언리얼 엔진은 이를 위해 패키지(UPackage)단위로 언리얼 오브젝트를 관리함.
 패키지의 중의적 개념
  언리얼 엔진은 다양한 곳에서 단어 패키지를 사용하고 있음
  언리얼 오브젝트를 감싼 포장 오브젝트를 의미함 (이번 강의의 주제)
  또한 개발된 최종 콘텐츠를 정리해 프로그램으로 만드는 작업을 의미함 ( 예) 게임 패키징)
  DLC와 같이 향후 확장 콘텐츠에 사용되는 별도의 데이터 묶음을 의미하기도 함 ( 예) pkg 파일)
[구분을 위해 언리얼 오브젝트 패키지로 부르는 것도 고려]

패키지(Package)와 애셋(Asset)
 언리얼 오브젝트 패키지는 다수의 언리얼 오브젝트를 포장하는데 사용하는 언리얼 오브젝트
  모든 언리얼 오브젝트는 패키지에 소속되어 있음 ( 예) Transient Package)
 언리얼 오브젝트 패키지의 서브 오브젝트를 애셋(Asset)이라고 하며 에디터에는 이들이 노출됨
 구조상 패키지는 다수의 언리얼 오브젝트를 소유할 수 있으나, 일반적으로는 하나의 애셋만 가짐
 애셋은 다시 다수의 서브오브젝트를 가질 수 있으며, 모두 언리얼 오브젝트 패키지에 포함됨.
  하지만 에디터에는 노출되지 않음
 
=== {패키지 사용 방법 영상 확인} ===

고유한 경로
/Game : 게임에서 사용되는 Asset들을 모아놓은 대표 폴더
/Temp : Saved 폴더에 매핑되어 있음

패키지 정보는 알기가 어려움 하지만 패키지에 속한 서브 오브젝트인 Asset의 정보는 에디터에서 자세하게 확인이 가능 

애셋 참조와 로딩
애셋 정보의 저장과 로딩 전략
 게임 제작 단계에서 애셋 간의 연결 작업을 위해 직접 패키지를 불러 할당하는 작업은 부하가 큼
  애셋 로딩 대신 패키지와 오브젝트를 지정한 문자열을 대체해 사용. 이를 오브젝트 경로라고 함
  프로젝트 내에 오브젝트 경로 값은 유일함을 보장함
  그렇기에 오브젝트 간의 연결은 오브젝트 경로 값으로 기록될 수 있음
  오브젝트 경로를 사용해 다양한 방법으로 애셋을 로딩할 수 있음
 애셋의 로딩 전략
  프로젝트에서 애셋이 반드시 필요한 경우 : 생성자 코드에서 미리 로딩
  런타임에서 필요한 때 바로 로딩하는 경우 : 런타임 로직에서 정적 로딩
  런타임에서 비동기적으로 로딩하는 경우 : 런타임 로직에서 관리자를 사용해 비동기 로딩

오브젝트 경로(Object Path)
 패키지 이름과 애셋 이름을 한 데 묶은 문자열
 애셋 클래스 정보는 생략할 수 있음
 패키지 내 데이터를 모두 로드하지 않고 오브젝트 경로를 사용해 필요한 애셋만 로드할 수 있음
ex)
{애셋클래스정보}'{패키지이름}.{애셋이름}'
또는
{패키지이름}.{애셋이름}

=== {도큐먼트 : 애셋참조} ===

애셋 참조
 강 참조 : 오브젝트 A가 오브젝트 B를 참조하여 오브젝트 A로드시 오브젝트 B가 로드되게 만드는 것
 약 참조 : 오브젝트 경로같은 문자열 형태의 간접 메커니즘을 통해 오브젝트 A가 오브젝트 B를 참조하게 만드는 것

애셋 스트리밍 관리자(Streamable Manager)
 애셋의 비동기 로딩을 지원하는 관리자 객체
 콘텐츠 제작과 무관한 싱글톤 클래스에 FStreamableManager를 선언해두면 좋음
  GameInstance는 좋은 선택지
 FStreamableManager를 활용해 애셋의 동기/비동기 로딩을 관리할 수 있음
 다수의 오브젝트 경로를 입력해 다수의 애셋을 로딩하는 것도 가능함.

=== {애셋 로드하는 방법 영상 확인} (비동기 방식 로드)===

FStreamableManager StreamableManager; 에서 
FStreamableManager은 포인터가 아니고 그냥 선언해주는 것으로 헤더를 추가해줘야함
==> #include "Engine/StreamableManager.h"

=======================================

15강

언리얼 빌드 시스템
 언리얼 에디터의 동작 방식을 이해하고, 언리얼 엔진의 독특한 모듈 시스템을 기반으로 소스코드와 플러그인 구조를 직접 제작하기

언리얼 엔진의 프로젝트 구성과 에디터 동작 방식의 이해
언리얼 엔진의 모듈 시스템을 기반으로 소스 코드를 구성하는 방법의 학습
언리얼 플러그인 시스템을 활용한 효과적인 모듈 구성의 학습

언리얼 에디터 구성
 게임 제작을 위해 에픽게임즈가 제공하는 저작 도구
 언리얼 엔진의 구성
  에디터 : 게임 제작을 위해 제공되는 응용 프로그램(일반적으로 인식하는 언리얼 엔진)
  게임 빌드 : EXE파일과 리소스로 이루어진 독립적으로 동작하는 게임 클라이언트
 언리얼 에디터의 특징
  게임 개발 작업을 위해 다양한 폴더와 파일 이름 규칙이 미리 설정되어 있다.
  정해진 규칙을 잘 파악하고 프로젝트 폴더와 파일을 설정해야 함
 에디터에서 기획과 개발을 완료한 후, 게임 빌드를 통해 최종 게임 빌드를 제작하도록 설정

언리얼 에디터의 동작
 프로젝트 폴더의 uproject 확장자를 더블클릭하면 에디터가 트리거 됨
 에디터의 실행 방식
  uproject 확장자는 윈도우 레지스트리에 등록되어 있음
   등록이 안되어 있다면 런처를 실행해 등록
  UnrealVersionSelector 프로그램으로 프로젝트 정보가 넘겨짐
  UnrealVersionSelector는 런처가 저장한 에디터 정보로부터 버전에 맞는 에디터를 실행함
 UnrealVersionSelector 소스는 에픽게임즈 GitHub에서 확인 가능

에디터 버전 정보의 파악
 프로젝트.uproject 텍스트 파일에 정해져있음
 .uproject 확장자는 에디터를 띄우기 위한 명세서 역할을 함
 버전 내용은 JSON 형식으로 구성되어 있음
 파일에 기록된 버전 정보를 바탕으로 에픽 런처가 지정한 정보를 찾아 에디터를 실행함.
  ProgramData/Epic/UnrealLauncher 폴더에 관련 정보가 있음
  이 역시 JSON 형식으로 설치된 언리얼 버전 정보가 기록되어 있음

Config 폴더 : 프로젝트 설정에 필요한 정보를 담고 있음
Content 폴더 : 애셋들을 보관
DerivedDataCache 폴더 : 사용하는 애셋들의 정보를 미리 캐싱하는데에 사용(용량이 급하다면 지워도 문제는 없지만 아마도 로딩속도 느릴것)
Intermediate 폴더 : 임시적으로 사용되는 중간 결과물들을 보관 (용량 체크해서 크다면 언제든지 삭제해도 무방하다)
Saved 폴더 : 임시로 무언가를 저장하는 용도로 활용(의도적으로 데이터를 저장하지 않았다면 지워도 무방)

블루프린트 프로젝트
 C++ 코드가 없는 언리얼 프로젝트
 언리얼 엔진이 제공하는 기본 기능을 활용해 게임을 제작하는 프로젝트
 언리얼 엔진은 게임 제작에 필요한 기능을 모듈이라는 단위로 제공하고 있음
 언리얼 엔진의 모듈을 상속받아 블루프린트를 활용해 모든 기능과 로직을 구현하는 방식

언리얼 C++ 프로젝트
 언리얼 엔진 C++ 모듈에 개발자가 추가로 자신만의 C++모듈을 추가할 수 있음
 언리얼 엔진 모듈과 개발자 모듈을 함께 사용하는 프로젝트

언리얼 C++모듈
 언리얼 엔진의 소스코드는 모두 모듈(Module)단위로 구성되어 있음
 모듈을 컴파일함으로서 에디터 및 게임에 우리가 제작한 로직을 공급할 수 있음
 모듈 단위로 구성된 C++ 소스 코드를 컴파일한 결과물
  에디터 용으로 DLL 동적 라이브러리
  게임 용으로는 정적 라이브러리
 에디터 용 모듈은 언제나 UnrealEditor-{모듈이름}.DLL 이라는 명명 규칙을 가지고 있음

언리얼 C++ 모듈의 추가
 기본 언리얼 모듈에 우리가 제작한 C++ 모듈을 추가해 에디터를 띄우고 싶은 경우
 우리가 만든 에디터 모듈(DLL 동적라이브러리)을 빌드 폴더에 넣어주어야 함
  Windows의 경우 Binaries/Win64 폴더에 해당 DLL을 넣어야 함
  빌드된 모듈 목록이 있는 UnrealEditor.modules 파일도 같은 폴더에 넣어주어야 인식됨
 uproject 명세서에 모듈 이름을 지정하고 에디터를 실행
==> Binaries폴더 통으로 복사해서 사용할 프로젝트에 붙여넣고 메모장 하나 켜서 uproject파일 드래그 후 내용 수정

모듈 C++ 코드의 관리
 언리얼 프로젝트가 소스 코드를 관리하는 규칙에 따라 소스 코드 구조를 구성해야 함
 소스 코드는 멀티 플랫폼 빌드 시스템을 지원하기 위해 특정 프로그램에 종속되어 있지 않음
 실제 빌드를 진행하는 주체 : Unreal Build Tool 이라는 C#프로그램
 Source 폴더에 지정된 규칙대로 소스를 넣으면 플랫폼에 맞춰서 알아서 컴파일 진행

Source 폴더의 구조
 Source 폴더
  타겟 설정 파일
  모듈 폴더(보통은 프로젝트 이름으로 모듈 이름을 지정)
   모듈 설정 파일
   소스 코드 파일(.h 및 .cpp 파일들)
 타겟 설정 파일 : 전체 솔루션이 다룰 빌드 대상을 지정함. 
  {프로젝트이름}.Target.cs : 게임 빌드 설정
  {프로젝트이름}Editor.Target.cs : 에디터 빌드 설정
 모듈 설정 파일 : 모듈을 빌드하기 위한 C++ 프로젝트 설정 정보
  {모듈이름}.Build.cs : 모듈을 빌드하기 위한 환경 설정
[C#이 가진 유연한 기능(complie on-the-fly)을 활용해 런타임에 cs파일을 읽어 빌드 환경을 구축하고 컴파일을 진행함]

게임 프로젝트의 소스
 내가 만든 소스가 게임 프로젝트의 C++ 모듈이 되기 위해 필요한 것
 모듈을 구현한 선언한 헤더와 소스파일이 있어야 함
  주로 {모듈이름}.h와 {모듈이름}.cpp로 지정함
 모듈의 뼈대를 제작
  매크로를 통해 기본 뼈대 구조를 제작
   IMPLEMENT_MODULE : 일반 모듈
   IMPLEMENT_GAME_MODULE : 게임 모듈
   IMPLEMENT_PRIMARY_GAME_MODULE : 주 게임 모듈
 일반적으로 게임 프로젝트는 주 게임 모듈을 하나 선언해야 함
[모든 준비가 완료되면 Generate Visual Studio project files. 메뉴를 선택]
[Intermediate 폴더에 프로젝트 관련 파일이 자동으로 생성됨]
★[Source 폴더를 규칙에 맞게 구성하면 Intermediate 폴더는 언제든지 재생성이 가능함]★

언리얼 엔진은 수 많은 모듈의 집합

모듈간의 종속 관계 
 모듈 사이에 종속 관계를 설정해 다양한 기능을 구현할 수 있다.
 우리가 만드는 게임 모듈도 언리얼 엔진이 만든 모듈을 활용해야 한다.
 언리얼 엔진이 제공하는 모듈 사이에도 종속 관계가 있음

새로운 모듈의 추가
 하나의 모듈에 너무 많은 코드가 들어가면 언리얼 엔진은 빌드 방식을 변경함
 그렇기에 프로젝트가 커질수록 모듈을 나누어서 관리하는 것이 유리함

모듈의 공개와 참조
 모듈 내 소스를 필요한 만큼만 공개해야 모듈간 의존성을 줄이고 컴파일 타임을 최소화 할 수 있음
 공개할 파일은 모두 Public 폴더로
  예외) 예전 언리얼 엔진은 Classes 폴더가 있어 Public 폴더 역할을 하면서 언리얼 오브젝트를 관리했음
 숨길 파일은 모두 Private 폴더로
 외부로 공개할 클래스 선언에는{모듈이름}_DLL 매크로를 붙일 것.
 게임 모듈에서는 Build.cs 설정을 통해 참조할 모듈을 지정할 수 있음
[주 게임 모듈은 서브 모듈에 의존하게 됨]
=> 서브 모듈에서 필요한 부분만 참조하도록 Public폴더/Private폴더 두 폴더 관리

플러그인 시스템
 게임 프로젝트 소스에 모듈을 추가하는 방법은 분업이 어렵다는 단점이 있음
 모듈만 독립적으로 동작하는 플러그인 구조를 만들어 분업화하는 것이 바람직함

플러그인 구조
 플러그인은 다수의 모듈과 게임 콘텐츠를 포함하는 포장 단위
 에디터 설정을 통해 유연하게 플러그인을 추가하거나 삭제할 수 있음
 플러그인 구조
  플러그인 명세서 (uplugin 파일)
  플러그인 리소스 (Resource 폴더, 에디터 메뉴용 아이콘)
  콘텐츠
  모듈 폴더
 이러한 플러그인은 마켓 플레이스 판매로도 이어질 수 있도록 여러 설정을 추가할 수 있음

=== {플러그인 사용 영상 확인} ===

주 게임 모듈을 참조할 다른 모듈이 있는 것은 설계에 좋지 않아서
Public/Private을 나누는 것은 사실상 의미 없음

플러그인 시스템은 Edit - Plugins - Other 에서 자유롭게 추가 삭제 가능

게임 빌드
 게임 타겟 설정을 추가하면 게임 빌드 옵션이 추가됨 (DebugGame, Development, Shipping)
  Shipping(사용자에게 배포할 최종 게임의 코드를 만들어내는 작업(모든 코드들이 최적화됨))
  => check, ensure와 같은 assertion 매크로들은 Shipping 빌드에서는 제외됨
  => 빌드가 수행되면 Binaries 폴더 - Win64에 exe파일이 생성됨
 게임 타겟으로 빌드된 모듈은 정적 라이브러리로 실행 파일에 포함됨
 게임이 실행되기 위해서는 실행 파일과 콘텐츠 애셋이 함께 있어야함
 빌드 : 실행 파일을 생성하기 위한 컴파일
 쿠킹 : 지정한 플랫폼에 맞춰 콘텐츠 애셋을 변환하는 작업

 패키징 : 이들을 모두 모아서 하나의 프로그램으로 만드는 작업
게임 패키지 : 실행 파일 + 콘텐츠 파일

에디터에서 Platform - Windows - Shipping 옵션체크 - Package Project 선택
 ==> 쿠킹과 빌드를 동시 작업

